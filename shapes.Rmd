---
title: "Data Shapes"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: 
      collapsed: false
    theme: yeti
    css: style.css
---

### Generating Patterns

#### Sample
```{r}
sample(c("yes","no","maybe"), replace = TRUE, 10, prob=c(0.8,0.1,0.1))
iris[sample(nrow(iris), 5), ] # 5 random observations from iris
```

#### Sequence
```{r}
seq(along.with = 15:11) == seq_along(1:5) # 1 2 3 4 5
seq(4,11, length=20)
seq(4,11, by=3.2)
```

We can also sequence along dates
```{r}
seq(as.Date("2000/1/1"), by = "month", length.out=12)
```

#### Replicate
```{r}
rep(c(1,2), times = 10) # 1 2 1 2 ...
rep(c(1,2), each = 10) # 111..222...
```

### Generating Noise

#### rnorm

We can specify means and sd for each individual number, or set a single value which is coerced into an appropriate length ie `rep(value, count)` for each number, otherwise by default `mean = 0` and `sd = 1`. 
```{r}
rnorm(3) # 3 random variables
rnorm(3, c(1, 10, 100)) # specifying means
```

#### By sampling

Sampling 100 elements randomly from a set containing 1000 rnorms and 1000 NAs.
```{r}
y <- rnorm(1000); z <- rep(NA,1000)
messy_data <- sample(c(y,z), 100)
my_na <- is.na(messy_data) # gives us a logical vector of where the NAs are
```

Since R represents TRUE as 1 and FALSE as 0, we can sum the TRUE and FALSE to get the total TRUEs:
```{r}
totalNAs <- sum(my_na); print(totalNAs)
```

#### jitter()

Using jitter to make a noisy sinewave
```{r}
x <- seq(-6, 6, by=0.2)
plot(x, jitter(sin(x), factor = 1, amount = 0.2))
```

### Data Manipulation

paste: sep, collapse see http://stackoverflow.com/questions/18475202/paste-collapse-in-r

subset, dplyr, tbl_df, paste, string stuff, regex

#### Subsetting

`[]` will always return an object of the same class as the original. It can be used to select more than one element.

`[[]]` is used to extract elems from a list or df. Can only extract one element (since elements could be of different classes) and the class of the returned object may not be the same as the original.

`$` is used to extract elems from a list or df by name. Similar semantics to `[[]]`.

```{r}
x <- list(numbers = 5:8, appletree = "a", age = 30)
class(x[1])
class(x[[1]])
x$appletree
identical(x$appletree, x[["appletree"]])
identical(x$appletree, x["appletree"])
x["appletree"]
```

Removing indices
```{r}
x <- 11:20
x[2:10]  # equivalent to `x[-1]`, "all but index 1"
x[c(-1,-5,-6)] # equivalent to x[-c(1,5,6)]
```

Logical index
```{r}
x <- 1:10
x[x > 6]
```

Logical vector
```{r}
x <- 1:5
u <- x > 3 # F F F T T
x[u]
```

Subsetting by name
```{r}
x <- list(a = "ok", b = 3.2, c = 11:14)
identical(x[[1]], x$a)
identical(x[[1]], x["a"])  # x["a"] == x$a
```

Nested extraction with `[[]]`
```{r}
x <- list(a = "ok", b = 3.2, c = 11:14)
x[[c(3,2)]] # 2nd elem of the 3rd elem
```

`[[]]` can be used with computed indices, `$` can only be used with literal names.
```{r}
x <- list(berries = 1:4, pennies = "a")
name <- "berries"
x[[name]]
x$name
```

Subsetting a matrix
```{r}
x <- matrix(1:6, 2, 3); print(x)
x[2,1]
x[1, ]  # first row
x[, 2]  # second column
```

`[]` usually returns an object as the same type, but `x[2,1]` returned a vector, not a matrix by default. This can be turned off by setting `drop = FALSE`.
```{r}
x[2, , drop = FALSE]
```

Partial Matching -- seems more problematic than useful
```{r}
x <- list(lamp = 1:3, lantern = 18:14)
x$la
x$lam
x[["lam"]]
x[["lam", exact = FALSE]]
```

Removing NAs by subsetting by a logical vector
```{r}
x <- c(1,2,NA,4,NA)
bad <- is.na(x)
x[!bad]
```

We can use complete.cases to return a logical vector that tells us which indices of the objects _all_ have no missing data
```{r}
y <- c(NA,2,3,4,NA)
good <- complete.cases(x,y); print(good)
x[good]
y[good]
```

Using complete.cases on a data frame
```{r}
fac <- sample(LETTERS[1:3], 5, replace = TRUE)
d <- data.frame(x = 1:5, y = 6:10, fac = fac)
d[1,2] <- NA; d[2,3] <- NA
good <- complete.cases(d)
d[good, ]  # keep good rows only, keep all columns
```

Splitting on a factor in a manner similar to `tapply`, we can divide a vector into subsets and then overfit each subset with a 5th degree polynomial, just for fun.
```{r}
x <- c(rnorm(10), 1:10+rnorm(10), sin(1:10))
fac <- gl(3, 10, labels=c("normal", "linear", "sine"))
plot(x)
y <- split(x,fac)
qplot(y=x, facets=fac ~ .) + geom_smooth(method="lm", formula = y ~ poly(x, 5))
```
