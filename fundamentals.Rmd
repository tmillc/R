---
title: "Fundamentals"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
    theme: yeti
    css: style.css
---

### Data Types

Worthwhile to also look at `?mode`, but probably has limited practical use.
```{r}
typeof(`[`)
mode(`[`)
unclass(`[`)
```

#### Numbers

Numbers are real (double) by default, we can specify integer by suffixing it with `L`.
```{r}
typeof(2)
typeof(2L)
```

#### Complex

```{r}
typeof(1+1i)  # often i might be used as a variable, so best to keep the coefficient
```


#### Logical

`TRUE`, `FALSE` are the logical constants in R, and `T`, `F` are global variables whose initial values are set to these. 

#### Vectors

Numbers (and logicals and characters) are actually vectors, of length 1, with class depending on their type. Vectors with length greater than 1 can be indexed, however their elements must have the same type.

```{r}
vector(mode = "character", length = 3)
```

All vectors can have names, it's an attribute that is get or set by `names`. 
```{r}
v1 <- 1:3
names(v1) <- c("a", "b", "c")
attributes(v1)
v1
```

#### List

A list is a special kind of vector which can have elements of different types. We can preallocate lists:
```{r}
vector("list", 3)
```

#### Factors

A factor is like a bunch of labels. “Yes”, “No”, “Maybe” for instance. In that case those three would be the Levels. The actual factor would be something like yes yes yes no maybe no no yes maybe. Factors are ordered or unordered. Yes, no, maybe is unordered but child, parent, grandparent would probably be ordered.

Here "a" is our baseline, the levels are lexicographic. 
```{r}
fac <- factor(c("a", "a", "c", "a", "c", "m", levels=c("m", "a","c"))); print(fac)
```

Reorder the factor levels:
```{r}
fac <- relevel(fac, ref="m"); print(fac)
```

Additionally we could assign to `levels` the order we prefer. Calling `levels(x)` will print the order of the factor levels.
```{r}
levels(fac) <- c("c", "m", "a")
table(fac)  # A quick way to see the order of the factors and how many belong to each level
```

Levels are numbers behind the scenes:
```{r}
unclass(fac)
```

We can generate factor levels with `gl`
```{r}
gl(3, 5, labels = c("Yes", "No", "Maybe"))
```

#### NA

Results next to each statement for space.
```{r, eval=FALSE}
Inf + Inf    # Inf
Inf - Inf    # NaN
Inf * Inf    # Inf
Inf / Inf    # NaN
0+0          # 0
0-0          # 0
0*0          # 0
0/0          # NaN
Inf * 0      # NaN
Inf + 0      # Inf
Inf - 0      # Inf
Inf / 0      # Inf
0 / Inf      # 0
Inf^0        # 1
0^Inf        # 0
0^0          # 1
is.na(NaN)   # TRUE
is.nan(NA)   # FALSE
```

#### Matrix

Matrices are vectors with a dimension attribute. Note that the matrix is populated column-by-column.
```{r}
v1 <- 1:6
dim(v1) <- c(2,3)
print(v1)
```

Calling `attributes` on an object prints that object's attributes, or attributes can also be assigned this way. 

```{r}
m1<-matrix(nrow = 3, ncol = 2)
attributes(m1)
identical(attributes(m1)$dim, dim(m1))
```

Giving dimension names to a matrix
```{r}
A <- matrix(nrow = 3, ncol = 2)
dimnames(A) <- list(c("row1", "row2", "row3"), c("col1", "col2"))
A
```

Generating dimension names for a matrix based on a prefix
```{r}
rnames <- rownames(A, do.NULL=FALSE, prefix="eqn")
cnames <- colnames(A, do.NULL=FALSE, prefix="var")
dimnames(A) <- list(rnames, cnames); print(A)
```

#### Data Frames

DFs are to matrices what lists are to vectors. Columns must be a single class. Tidy data says to have each row a single observation.

```{r}
data.frame(id = 1:4, truth = c(T,T,F,T))
```

### Control Structures

#### if/(else if)/(else)

An `else if` or `else` statement is optional following `if` in R.
```{r}
if(3 > 2) {
  y <- "yep"
} else if (3 == 2) {
  y <- "uh oh"
} else {
  y <- "uh oh"
}
print(y)
```

#### For

The following examples are equivalent:
```{r}
x <- c("a", "b", "c", "d")

for (i in 1:4) {
  print(x[i])
}

for (i in seq_along(x)) {
  print(x[i])
}

for (letter in x) {
  print(letter)
}

for (i in seq_len(4)) { 
  print(x[i])
}

for (i in 1:4) print(x[i])
```

Note the last example, `{}` are unnecessary for single statements.

Traditional method of nesting `for` loops, however we often have the option of vectorizing such operations.
```{r}
x<-matrix(1:6, 2, 3)

for (i in seq_len(nrow(x))) {
  for (j in seq_len(ncol(x))) {
    print(x[i,j])
  }
}
```

#### While
```{r}
count <- 0
while(count<10) {
  print(count)
  count <- count + 1
}
```

Here we decide the result of `if` by a simulated coin flip, constraining the simulation with a `while` loop.
```{r}
z<-5
while(z>=3 && z<=10) {
  print(z)
  coin <- rbinom(1,1,0.5)

  if(coin == 1) {    # random walk
    z <- z+1
  } else {
    z <- z-1
  }
}
```

#### Break

**Note from ?control**

>it is a common mistake to forget to put `{...}` around your statements, e.g., after `if(...)` or `for(....)`. In particular, you should not have a newline between `}` and `else` to avoid a syntax error in entering an `if ... else` construct at the keyboard or via source. For that reason, one (somewhat extreme) attitude of defensive programming is to always use braces, e.g., for if clauses.

#### Ifelse
```{r}
ifelse(3 > 2, yes = print("yes"), no = print("no"))
ifelse(3 < 2, yes = print("yes"), no = print("no"))
```

#### Switch

#### Repeat

Warning: not guarenteed to halt, better to set hard limit on number of iterations, and report con-/di-vergence.
```{r, eval=FALSE}
x0 <- 1
tol <- 1e-8

repeat {
  x1 <- computeSomeEstimate()

  if (abs(x1-x0) < tol) {
    break # we are within some tolerance, so break
  } else {
    x0 <- x1
  }
}
```

#### Next

Here we skip the first 20 iterations and `doSomething` on the last 80.
```{r, eval=FALSE}
for(i in 1:100) {
  if(i <= 20) {
    next 				
  }
  doSomething()
}
```

#### Return



#### Assigning

We can assign from control structures:
```{r}
y <- if(3 > 2) {
  "yep"
} else {
  "uh oh"
}
print(y)
```

### Coercion

Coerce to matrix, note the T's and F's
```{r}
x <- data.frame(id = 1:4, truth = c(T,T,F,T))
data.matrix(x)
```

```{r}
my_matrix <- matrix(1:20, 4,5)
patients <- c("Sean", "Bill", "Claude", "Kelly")
cbind(patients, my_matrix)       # coerces everything to char
data.frame(patients, my_matrix)  # patients is char, matrix is matrix
```

```{r}
as.logical(-2:2)
as.numeric(TRUE)
as.numeric(c("a","b","c"))  # no way to coerce char -> num
typeof(c(TRUE, "hi"))
```

### IO, files

#### Files

Filesystem independent path reference, nest dirs by recursive = TRUE. `unlink` deletes files and directories.
```{r}
file.path("folder1", "folder2")
dir.create(file.path("testdir2", "tesdtdir3"), recursive = TRUE)
unlink("testdir2", recursive = TRUE)
```

`file.info` returns a dataframe with _size_, _isdir_, etc.

file.rename, ls, dir

#### RW Data

* `read.table` (inverse of write.table) and `read.csv` (identical to read.table, but assumes comma-sep and header=true): takes in tabular data and return a data frame
* `readLines` (inverse of writeLines): reads lines of a text file in as a character vector
* `dget` (inverse of dput): reads in de-parsed R objects
* `source` (inverse of dump): reads in R source code
* `load` (inverse of save): for workspaces
* `unserialize` (inverse of serialize): for binary data

Specify `read.table` arguments explicitly for speed. Not also `stringsAsFactors` - When it comes across a col that’s a character variable it’ll assume it to be a factor

To load large datasets with `read.table`, make a rough calculation of memory required to hold dataset. If dataset > RAM, probably stop. Set comment.char = “” if no comment lines. Setting colClasses can speed up a LOT.

Quick and dirty way to assign colClasses: Look at the first 100 data to set classes, then set these explicitly on the entire dataset.
```{r, eval=FALSE}
initial <- read.table("dataset.txt", nrows = 100)
classes <- sapply(initial, class)
tabAll <- read.table("dataset.txt", colClasses = classes)
```

Setting nrows won’t speed up R but helps with memory usage. Mild overestimate is okay. Using ‘wc’ can tell the # of lines.

#### Memory Estimate

Ex: 1.5 million rows, 120 cols, all numeric. 1.5mil * 120 * 8 (8 bytes per numeric) ~1.34 Gb. Rule of thumb: Need about twice that to load it into R, with overhead, so ~3Gb

#### dump/dput

* preserves metadata contrasting outputing to table/csv
* edit-able, so in case of corruption, can be opened and examined
* also good for version control
* is a textual format rather than a binary
* not space efficient though

```{r, eval=FALSE}
y <- data.frame(apple = 0.3, coffee = "almonds")
dput(y, file = "y.R")
```

Here we could also dput(y) to print to the console.
```{r, eval=FALSE}
y2 <- dget("y.R")
```

Dump is similar, but deals with multiple objects.
```{r, eval=FALSE}
x <- "hello"; y <- 1:4; dump(c("x", "y"), file = "data.R")
rm(x,y)  # gone from workspace
source("data.R") # x,y are back
```

`file`, `bzfile`, `gzfile`: opens connection to a compressed file.

```{r eval=FALSE} 
data <- read.csv(“data.txt”) 
con <- file(“data.txt”, “r”) # opening for reading 
data <- read.csv(con) 
close(con)
```

Can use a file connection to read parts of a file. Here, `x[1]` is the first line of test.gz, `x[10]` is the tenth.
```{r, eval=FALSE}
con <- gzfile("test.gz")
x <- readLines(con, 10)
```

#### Connections

`url`: opens connection to a website, sql, 

### Functions

Functions are first-class in R: they can be passed, and defined in a scope. The return value is the last expression evaluated.

Interestingly, even `[]` is a function. Rather, `[` is. To use it we must surround it in backticks.

```{r}
`[`(c(5,6,7,8), 2)
```

#### Arguments

```{r}
formals(rnorm)
```

An interesting look at how `formals` and `alist` work
```{r}
f <- function() x
formals(f) <- al <- alist(x =, y = NULL, ... =)
print(f)
print(al)
```

The following demonstrates some things about argument order.
```{r, eval=FALSE}
mydata <- rnorm(100)
sd(mydata)      # mydata is passed as the first argument, the rest are default
sd(x = mydata)  # equivalent to above
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata) # fine, but not recommended to change around order
sd(na.rm = FALSE, mydata)     # since mydata is unnamed, it will be assigned to the first expected argument, x
```

When an argument is matched by name, it is "taken out" of the list, and following arguments will be matched in order.

#### Lazy Evaluation

Here, `c` has a default value, but `b` doesn't, but `b` isn't used so we don't really care.
```{r}
f1 <- function(a, b, c = TRUE) {
  a^2
}

f2 <- function(a,b) {
  print(a)
  print(b)
}
```

Calling `f2(45)` will print 45, THEN error, because 45 will match for `a`, and `b` will be unmatched when it is called.

#### ...

`...` argument indicates a variable number of arguments that are usually passed on to other functions.

```{r}
myplot <- function(x, y, type="l", ... ) { # extends plot()
  plot(x, y, type = type, ... )
}
```

`paste` doesn't know how many objects it will be pasting, so ... is the first argument
```{r}
args(paste)
```

**NOTE**: Arguments that appear after the ... must be explicitly named (and cannot be partially matched).

dotdotdot example .R

#### Vectorized Operations

Element-wise addition of vectors
```{r}
x <- 0:3; y <- 20:23
print(x+y)
```

Element-wise comparison
```{r}
x == 2
```

### Recycling

When adding a scalar (in R, a vector of length 1) to a vector, R computes x+2 by first creating a vector of 2's the length of x.
```{r}
x+2
```

This is equivalent to `x + c(2,2,2,2)`.

If R runs out of elements in a vector operation, it will “recycle” them, if the lengths are not multiples it will give a warning but return a truncated cycle.
```{r}
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,1,2) 
```

### Matrices
```{r}
x <- matrix(1:4, 2,2); y <- matrix(rep(10,4), 2,2)
x / y  # element-wise division
x * y  # element-wise multiplication
x %*% y  # True matrix multiplication
```

### lapply

The `*apply` family apply functions over a list or vector. 

Maybe we need a set of random uniform variables: 1 runif, then 3 runifs, then 6 runifs:
```{r}
x <- c(1,3,6)
lapply(x, runif) 
```

We can apply a function to every list element:
```{r}
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
```

We can pass arguments to the function:
```{r}
x <- list(a = sample(letters, 6), b = sample(letters, 3), c = sample(letters, 5))
lapply(x, paste, collapse="")
```

Using an anonymous function, we can decide further what exactly to do with the input to `lapply`. Here, we are making sequences from 0 to 1 of length given by the input object.
```{r}
lapply(c(3, 4, 5), function(x) seq(from = 0, to = 1, length = x))
```

### sapply

`sapply` is a wrapper to `lapply`. If the result is a list where every element is a vector of same length (>1), `sapply` returns a matrix. If it can't figure it out, it returns a list.
```{r}
x <- list(a = 5:9, b = rnorm(5))
sapply(x, mean)
sapply(x, print)
```

Using `lapply` here returns a list instead of a simple vector, which introduces unnecessary overhead, requiring almost 7 times as much space for a simple set of integers.
```{r}
x <- 1:100

doubleMe <- function(n) n*2
y <- sapply(x, doubleMe)

doubleMe <- function(n) n*2
z <- lapply(x, doubleMe)

as.numeric(object.size(z) / object.size(y))
```

Here we have a list of matrices, and extract the first columns of each. Because returning a vector doesn't quite make sense here, `sapply` smartly gives us a list, as `lapply` would do.
```{r}
x <- list(a = matrix(1:4, 2,2), b = matrix(1:6, 3,2))
sapply(x, function(y) y[,1])
```

### apply 

`apply` evalutes a function over the margins of an array, most often used to apply a function to the rows/cols of a matrix. It can be used with general arrays, eg taking avg of an array of matrices. It's not really faster than a loop, but works in one line.

```{r}
str(apply)
# X is an array
# MARGIN is an int vector indicating which margins (think dimensions) we wish to preserve
# FUN is the function we're applying
# ... is for args to FUN
```

Here is an array with rows, cols and depth. We could use `apply` to sum over the different dimensions.
```{r}
x <- array(1:24, c(4,3,2)) # A "2-deep" array with 4 rows and 3 columns.
print(x)
apply(x, MARGIN = 2, sum)   # applying sum to the columns
# 1+2+3+4+13+14+15+16 = 68
# 5+6+7+8+17+18+19+20 = 100
# 9+10+11+12+21+22+23+24 = 132

apply(x, 1, sum)   # applying sum to the rows
# 1+5+9+13+17+21 = 66, etc

apply(x, 3, sum)   # applying sum to the depth
# sum(1:12) = 78
# sum(13:24) = 222
```

We can preserve both rows and cols, collapsing depth.
```{r}
apply(x,c(1,2), sum)
# Across the first row: 1+13 = 14, 5+17 = 22, 9+21 = 30
```

There are some built-in operations that are faster for certain matrix (2-array) operations. However, if you are dealing with higher-dimensional arrays or have more exotic functions than `sum` or `mean`, then using `apply` may be a simpler option than reshaping your data. But as seen from the following benchmarking, the built-in operations are quite a bit faster.
```{r}
library(microbenchmark)

x <- matrix(20:79, 6,10)
rowSums(x) == apply(x,1,sum)
microbenchmark(rowSums(x))
microbenchmark(apply(x, 1, sum))

colMeans(x) == apply(x,2,mean)
microbenchmark(colMeans(x))
microbenchmark(apply(x,2,mean))

```

Here we feed a matrix with 20 rows, 10 columns into `apply`, and have it return the 25%, and 75% distribution quantiles for each row.

```{r}
x <- matrix(rnorm(200), 20,10)  # 20x10 matrix
t(apply(x, 1, quantile, probs=c(0.25, 0.75)))
# Since we are returning the 2 quantiles for each row,
# apply() gives us a 2x20 matrix, which we transpose
# with t()
```

If we have a bunch of 2x2 matrices, we can get their element-wise averages. We can specify `dims` in `rowMeans` to accomplish this as well. As expected, `rowMeans` performs much better, but again lacks the flexibility (and perhaps clarity, after one is used to the syntax) of `apply`. 
```{r}
x <- array(rnorm(2*2*1000), c(2,2,1000))
x[, , 1]   # We have 10 of these

apply(x, c(1,2), mean)
rowMeans(x, dims = 2)
```

### tapply

`tapply` applies a function to a subset of a vector. It defaults to simplifying the return value, but the argument `simplify = FALSE` overrides this and returns a list. Here we are generating a factor `f` of 4 levels, 10 each, and using this to subset our vector for `tapply`.
```{r}
x <- c(rnorm(10, mean = 3), runif(10), 1:10, sin(-5:4))
f <- gl(4, 10, labels = c("rnorm", "runif", "1:10", "sine"))
tapply(x, f, mean)
tapply(x, f, summary)
```

This is a helpful operation for data which comes with, or has a natural, factor variable
```{r}
tapply(iris$Petal.Length, iris$Species, summary)
```

### Vectorize

See `?Vectorize` to better understand this

#### Scope 

#### anonymous/closure/lambda 
```{r}
x <- list(a = matrix(1:4, 2,2), b= matrix(1:6, 3,2))
lapply(x, function(y) y[,1])
```

```{r}
f1 <- function(x) ifelse(x >= 0, sqrt(x), NA)
f1(2)
f1(-1)
```

>A closure has three components, its formals (its argument list), its body (expr in the ‘Usage’ section) and its environment which provides the enclosure of the evaluation frame when the closure is used.


TODO: benchmark/profiling section