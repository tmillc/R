---
title: "Fundamentals"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
    theme: yeti
    css: style.css
---

### Data Types

Worthwhile to also look at `?mode`, but probably has limited practical use.
```{r}
typeof(`[`)
mode(`[`)
unclass(`[`)
```

#### Numbers

Numbers are real (double) by default, we can specify integer by suffixing it with `L`.
```{r}
typeof(2)
typeof(2L)
```

#### Complex

```{r}
typeof(1+1i)  # often i might be used as a variable, so best to keep the coefficient
```


#### Logical

`TRUE`, `FALSE` are the logical constants in R, and `T`, `F` are global variables whose initial values are set to these. 

#### Vectors

Numbers (and logicals and characters) are actually vectors, of length 1, with class depending on their type. Vectors with length greater than 1 can be indexed, however their elements must have the same type.

```{r}
vector(mode = "character", length = 3)
```

All vectors can have names, it's an attribute that is get or set by `names`. 
```{r}
v1 <- 1:3
names(v1) <- c("a", "b", "c")
attributes(v1)
v1
```

#### List

A list is a special kind of vector which can have elements of different types. We can preallocate lists:
```{r}
vector("list", 3)
```

#### Factors

A factor is like a bunch of labels. “Yes”, “No”, “Maybe” for instance. In that case those three would be the Levels. The actual factor would be something like yes yes yes no maybe no no yes maybe. Factors are ordered or unordered. Yes, no, maybe is unordered but child, parent, grandparent would probably be ordered.

Here "a" is our baseline, the levels are lexicographic. 
```{r}
fac <- factor(c("a", "a", "c", "a", "c", "m", levels=c("m", "a","c"))); print(fac)
```

Reorder the factor levels:
```{r}
fac <- relevel(fac, ref="m"); print(fac)
```

Additionally we could assign to `levels` the order we prefer. Calling `levels(x)` will print the order of the factor levels.
```{r}
levels(fac) <- c("c", "m", "a")
table(fac)  # A quick way to see the order of the factors and how many belong to each level
```

Levels are numbers behind the scenes:
```{r}
unclass(fac)
```

#### NA

Results next to each statement for space.
```{r, eval=FALSE}
Inf + Inf    # Inf
Inf - Inf    # NaN
Inf * Inf    # Inf
Inf / Inf    # NaN
0+0          # 0
0-0          # 0
0*0          # 0
0/0          # NaN
Inf * 0      # NaN
Inf + 0      # Inf
Inf - 0      # Inf
Inf / 0      # Inf
0 / Inf      # 0
Inf^0        # 1
0^Inf        # 0
0^0          # 1
is.na(NaN)   # TRUE
is.nan(NA)   # FALSE
```

#### Matrix

Matrices are vectors with a dimension attribute. Note that the matrix is populated column-by-column.
```{r}
v1 <- 1:6
dim(v1) <- c(2,3)
print(v1)
```

Calling `attributes` on an object prints that object's attributes, or attributes can also be assigned this way. 

```{r}
m1<-matrix(nrow = 3, ncol = 2)
attributes(m1)
identical(attributes(m1)$dim, dim(m1))
```

Giving dimension names to a matrix
```{r}
A <- matrix(nrow = 3, ncol = 2)
dimnames(A) <- list(c("row1", "row2", "row3"), c("col1", "col2"))
A
```

Generating dimension names for a matrix based on a prefix
```{r}
rnames <- rownames(A, do.NULL=FALSE, prefix="eqn")
cnames <- colnames(A, do.NULL=FALSE, prefix="var")
dimnames(A) <- list(rnames, cnames); print(A)
```

#### Data Frames

DFs are to matrices what lists are to vectors. Columns must be a single class. Tidy data says to have each row a single observation.

```{r}
data.frame(id = 1:4, truth = c(T,T,F,T))
```

### Control Structures

#### if/(else if)/(else)

An `else if` or `else` statement is optional following `if` in R.
```{r}
if(3 > 2) {
  y <- "yep"
} else if (3 == 2) {
  y <- "uh oh"
} else {
  y <- "uh oh"
}
print(y)
```

#### For

The following examples are equivalent:
```{r}
x <- c("a", "b", "c", "d")

for (i in 1:4) {
  print(x[i])
}

for (i in seq_along(x)) {
  print(x[i])
}

for (letter in x) {
  print(letter)
}

for (i in seq_len(4)) { 
  print(x[i])
}

for (i in 1:4) print(x[i])
```

Note the last example, `{}` are unnecessary for single statements.

Traditional method of nesting `for` loops, however we often have the option of vectorizing such operations.
```{r}
x<-matrix(1:6, 2, 3)

for (i in seq_len(nrow(x))) {
  for (j in seq_len(ncol(x))) {
    print(x[i,j])
  }
}
```

#### While
```{r}
count <- 0
while(count<10) {
  print(count)
  count <- count + 1
}
```

Here we decide the result of `if` by a simulated coin flip, constraining the simulation with a `while` loop.
```{r}
z<-5
while(z>=3 && z<=10) {
  print(z)
  coin <- rbinom(1,1,0.5)

  if(coin == 1) {    # random walk
    z <- z+1
  } else {
    z <- z-1
  }
}
```

#### Break

**Note from ?control**

>it is a common mistake to forget to put `{...}` around your statements, e.g., after `if(...)` or `for(....)`. In particular, you should not have a newline between `}` and `else` to avoid a syntax error in entering an `if ... else` construct at the keyboard or via source. For that reason, one (somewhat extreme) attitude of defensive programming is to always use braces, e.g., for if clauses.

#### Ifelse
```{r}
ifelse(3 > 2, yes = print("yes"), no = print("no"))
ifelse(3 < 2, yes = print("yes"), no = print("no"))
```

#### Switch

#### Repeat

Warning: not guarenteed to halt, better to set hard limit on number of iterations, and report con-/di-vergence.
```{r, eval=FALSE}
x0 <- 1
tol <- 1e-8

repeat {
  x1 <- computeSomeEstimate()

  if (abs(x1-x0) < tol) {
    break # we are within some tolerance, so break
  } else {
    x0 <- x1
  }
}
```

#### Next

Here we skip the first 20 iterations and `doSomething` on the last 80.
```{r, eval=FALSE}
for(i in 1:100) {
  if(i <= 20) {
    next 				
  }
  doSomething()
}
```

#### Return



#### Assigning

We can assign from control structures:
```{r}
y <- if(3 > 2) {
  "yep"
} else {
  "uh oh"
}
print(y)
```

### Coercion

Coerce to matrix, note the T's and F's
```{r}
x <- data.frame(id = 1:4, truth = c(T,T,F,T))
data.matrix(x)
```

```{r}
my_matrix <- matrix(1:20, 4,5)
patients <- c("Sean", "Bill", "Claude", "Kelly")
cbind(patients, my_matrix)       # coerces everything to char
data.frame(patients, my_matrix)  # patients is char, matrix is matrix
```

```{r}
as.logical(-2:2)
as.numeric(TRUE)
as.numeric(c("a","b","c"))  # no way to coerce char -> num
typeof(c(TRUE, "hi"))
```

### IO, files

#### Files

Filesystem independent path reference, nest dirs by recursive = TRUE. `unlink` deletes files and directories.
```{r}
file.path("folder1", "folder2")
dir.create(file.path("testdir2", "tesdtdir3"), recursive = TRUE)
unlink("testdir2", recursive = TRUE)
```

`file.info` returns a dataframe with _size_, _isdir_, etc.

file.rename, ls, dir

#### RW Data

* `read.table` (inverse of write.table) and `read.csv` (identical to read.table, but assumes comma-sep and header=true): takes in tabular data and return a data frame
* `readLines` (inverse of writeLines): reads lines of a text file in as a character vector
* `dget` (inverse of dput): reads in de-parsed R objects
* `source` (inverse of dump): reads in R source code
* `load` (inverse of save): for workspaces
* `unserialize` (inverse of serialize): for binary data

Specify `read.table` arguments explicitly for speed. Not also `stringsAsFactors` - When it comes across a col that’s a character variable it’ll assume it to be a factor

To load large datasets with `read.table`, make a rough calculation of memory required to hold dataset. If dataset > RAM, probably stop. Set comment.char = “” if no comment lines. Setting colClasses can speed up a LOT.

Quick and dirty way to assign colClasses: Look at the first 100 data to set classes, then set these explicitly on the entire dataset.
```{r, eval=FALSE}
initial <- read.table("dataset.txt", nrows = 100)
classes <- sapply(initial, class)
tabAll <- read.table("dataset.txt", colClasses = classes)
```

Setting nrows won’t speed up R but helps with memory usage. Mild overestimate is okay. Using ‘wc’ can tell the # of lines.

#### Memory Estimate

Ex: 1.5 million rows, 120 cols, all numeric. 1.5mil * 120 * 8 (8 bytes per numeric) ~1.34 Gb. Rule of thumb: Need about twice that to load it into R, with overhead, so ~3Gb

#### dump/dput

* preserves metadata contrasting outputing to table/csv
* edit-able, so in case of corruption, can be opened and examined
* also good for version control
* is a textual format rather than a binary
* not space efficient though

```{r, eval=FALSE}
y <- data.frame(apple = 0.3, coffee = "almonds")
dput(y, file = "y.R")
```

Here we could also dput(y) to print to the console.
```{r, eval=FALSE}
y2 <- dget("y.R")
```

Dump is similar, but deals with multiple objects.
```{r, eval=FALSE}
x <- "hello"; y <- 1:4; dump(c("x", "y"), file = "data.R")
rm(x,y)  # gone from workspace
source("data.R") # x,y are back
```

`file`, `bzfile`, `gzfile`: opens connection to a compressed file.

```{r eval=FALSE} 
data <- read.csv(“data.txt”) 
con <- file(“data.txt”, “r”) # opening for reading 
data <- read.csv(con) 
close(con)
```

Can use a file connection to read parts of a file. Here, `x[1]` is the first line of test.gz, `x[10]` is the tenth.
```{r, eval=FALSE}
con <- gzfile("test.gz")
x <- readLines(con, 10)
```

#### Connections

`url`: opens connection to a website, sql, 

### Functions

Functions are first-class in R: they can be passed, and defined in a scope. The return value is the last expression evaluated.

```{r}
formals(rnorm)
```

#### Arguments

An interesting look at how `formals` and `alist` work
```{r}
f <- function() x
formals(f) <- al <- alist(x =, y = NULL, ... =)
print(f)
print(al)
```

The following demonstrates some things about argument order.
```{r, eval=FALSE}
mydata <- rnorm(100)
sd(mydata)      # mydata is passed as the first argument, the rest are default
sd(x = mydata)  # equivalent to above
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata) # fine, but not recommended to change around order
sd(na.rm = FALSE, mydata)     # since mydata is unnamed, it will be assigned to the first expected argument, x
```

When an argument is matched by name, it is "taken out" of the list, and following arguments will be matched in order.

#### Lazy Evaluation

Here, `c` has a default value, but `b` doesn't, but `b` isn't used so we don't really care.
```{r}
f1 <- function(a, b, c = TRUE) {
  a^2
}

f2 <- function(a,b) {
  print(a)
  print(b)
}
```

Calling `f2(45)` will print 45, THEN error, because 45 will match for `a`, and `b` will be unmatched when it is called.

#### ...

`...` argument indicates a variable number of arguments that are usually passed on to other functions.

```{r}
myplot <- function(x, y, type="l", ... ) { # extends plot()
  plot(x, y, type = type, ... )
}
```

`paste` doesn't know how many objects it will be pasting, so ... is the first argument
```{r}
args(paste)
```

**NOTE**: Arguments that appear after the ... must be explicitly named (and cannot be partially matched).

dotdotdot example .R

#### Vectorized Operations

Element-wise addition of vectors
```{r}
x <- 0:3; y <- 20:23
print(x+y)
```

Element-wise comparison
```{r}
x == 2
```

### Recycling

When adding a scalar (in R, a vector of length 1) to a vector, R computes x+2 by first creating a vector of 2's the length of x.
```{r}
x+2
```

This is equivalent to `x + c(2,2,2,2)`.

If R runs out of elements in a vector operation, it will “recycle” them, if the lengths are not multiples it will give a warning but return a truncated cycle.
```{r}
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,1,2) 
```

### Vectorize

See `?Vectorize` to better understand this

### lapply

The `*apply` family apply functions over a list or vector. 

Maybe we need a set of random uniform variables: 1 runif, then 3 runifs, then 6 runifs:
```{r}
x <- c(1,3,6)
lapply(x, runif) 
```

We can apply a function to every list element:
```{r}
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
```

We can pass arguments to the function:
```{r}
x <- list(a = sample(letters, 6), b = sample(letters, 3), c = sample(letters, 5))
lapply(x, paste, collapse="")
```

Using an anonymous function, we can decide further what exactly to do with the input to `lapply`. Here, we are making sequences from 0 to 1 of length given by the input object.
```{r}
lapply(c(3, 4, 5), function(x) seq(from = 0, to = 1, length = x))
```

### sapply

`sapply` is a wrapper to `lapply`, by default returning a vector, matrix or array. 
```{r}
x <- list(a = 1:5, b = rnorm(10))
sapply(x, mean)
```

Using `lapply` here returns a list instead of a simple vector, which introduces unnecessary overhead, requiring almost 7 times as much space for a simple set of integers.
```{r}
x <- 1:100

doubleMe <- function(n) n*2
y <- sapply(x, doubleMe)

doubleMe <- function(n) n*2
z <- lapply(x, doubleMe)

as.numeric(object.size(z) / object.size(y))
```

Here we have a list of matrices, and extract the first columns of each. Because returning a vector doesn't quite make sense here, `sapply` smartly gives us a list, as `lapply` would do.
```{r}
x <- list(a = matrix(1:4, 2,2), b = matrix(1:6, 3,2))
sapply(x, function(y) y[,1])
```


### Matrices
```{r}
x <- matrix(1:4, 2,2); y <- matrix(rep(10,4), 2,2)
x / y  # element-wise division
x * y  # element-wise multiplication
x %*% y  # True matrix multiplication
```


(some topic generally on functions)

Interestingly, even `[]` is a function. Rather, `[` is. To use it we must surround it in backticks.

```{r}
`[`(c(5,6,7,8), 2)
```

#### Scope 

#### anonymous/closure/lambda 
```{r}
x <- list(a = matrix(1:4, 2,2), b= matrix(1:6, 3,2))
lapply(x, function(y) y[,1])
```

```{r}
f1 <- function(x) ifelse(x >= 0, sqrt(x), NA)
f1(2)
f1(-1)
```

>A closure has three components, its formals (its argument list), its body (expr in the ‘Usage’ section) and its environment which provides the enclosure of the evaluation frame when the closure is used.

