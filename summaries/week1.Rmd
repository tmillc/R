---
title: "    Week 1"
author: "C"
date: "ok"
---
## Early sutff
*Atomic classes*:   numeric, integer, logical, complex, character
*vectors*   elements all of the same class, *list*: multiple classes, it's a type of vector
```{r}
vector("numeric", length=10)
```
```{r}
vector("list", length=3)
```
*Coercion*   different types will be coerced, if they can.
```{r}
as.numeric(TRUE)
as.logical(-2:2)    # everything non-zero is True
as.numeric(1+1i)    # we lose the imaginary part
as.numeric(c("a","b","c"))  # no way to coerce char -> num
```

## Workspace and files
- ls(): objects in your environment

- dir() or list.files(): files in your working directory

- file.info(): gets info about a file, returns a data frame, so you can reference columns ie file.info("file")$size

- file.rename(): renames a file

- unlink(): deletes files and directories
Setting dir to a subdir using paste example
```{r eval=FALSE}
dir.create("woo")
setwd(paste(getwd(), "/woo", sep = ""))
# another paste example, and vector recycling
paste(LETTERS, 1:4, sep = "-")
```
See also http://stackoverflow.com/questions/18475202/paste-collapse-in-r for 'sep' and 'collapse' in paste()

Can create a filesystem independent way of referencing paths, and nest directories by setting recursive = TRUE.
```{r eval=FALSE}
file.path("folder1", "folder2")
dir.create(file.path("testdir2", "testdir3"), recursive = TRUE)
```
Nested directories by way of recursive = TRUE in dir.create

## Sequences
```{r}
pi:10  # upper limit isn't hit
my_seq <- 15:11    # can count backwards, equivalent seq(15,11)
seq(4,11, length=20)  # can just specify length of seq
15:length(LETTERS)
seq(along.with = my_seq)  # equiv seq_along(my_seq)
rep(c(1,2), times = 10)
rep(c(1,2), each = 10)
```
To get help with ie :, we have to enclose them in backticks
```{r}
# seq by date
seq(as.Date("2000/1/1"), by="month", length.out=12)
```

## Missing Data
```{r}
y <- rnorm(1000); z <- rep(NA,1000)
messy_data <- sample(c(y,z), 100)  # we don't know how many or where the NA's are
my_na <- is.na(messy_data)  # now we know where they are and sum(my_na) tells how many
```
#### Two ways to get NaN
0/0, Inf - Inf

## Matrices
Also a special kind of vector, a vector with a dimension attribute.
```{r}
A <- matrix(nrow = 3, ncol = 2)
attributes(A)
dimnames(A) <- list(c("row1", "row2", "row3"), c("col1", "col2"))
print(A)
```
Apply a dimension attribute to a vector to get a matrix.
```{r}
v1 <- 1:6
dim(v1) <- c(2,3)
print(v1)
```
cbind and rbind:
```{r}
v2 <- 1:3; v3 <- 5:7
print(cbind(v2,v3))
print(rbind(v2,v3))
```

```{r}
my_matrix <- matrix(1:20, 4,5) # a 4x5 numeric matrix
patients <- c("Sean", "Bill", "Claude", "Kelly")
cbind(patients, my_matrix)
# Oops, the matrix was coerced to be characters
# Data frame instead
data.frame(patients, my_matrix)
# We could use colnames(my_data) <- char_vector to give column names
```

## Factors
A *factor* is like a bunch of labels. "Yes", "No", "Maybe" for instance. In that case those three
would be the Levels. The actual factor would be something like yes yes yes no maybe no no yes maybe.

Factors are *ordered* or *unordered*. Yes, no, maybe is unordered but child, parent, grandparent would
probably be ordered.
```{r}
charVec <- sample(c("yes","no","maybe"), replace = TRUE, 10, prob=c(0.8,0.1,0.1))
# A factor of yes/no/maybe, given by a random sampling with heavy weight given to "yes".
fac <- factor(charVec); print(fac)
factor(c("a", "a", "c", "a", "c", "m", levels=c("m", "a","c"))) # "m" is our baseline
```

```{r}
relevel(fac, ref = "yes")
```
Releveled with *yes* as the reference. As shown above, we can set levels when making the factor.

There's a lot about object classes in ?class but unclass() shows us some raw-ness.
```{r}
unclass(fac)
```
We can also get some good info by str()
```{r}
str(fac)
```
A NaN is a type of NA.
```{r}
x <- c(1,NA,NA,NaN,NA,NA,1)
is.na(x)
is.nan(x)
```

## Data frames
are to matrices what lists are to vectors, pretty much. Columns must be a single class.
Tidy data says to have each row a single observation.
```{r}
x <- data.frame(id = 1:4, truth = c(T,T,F,T)); print(x)
# Can convert to a matrix, coercing values of course
data.matrix(x)
```
## Names
All R objects can have names.
- names(), dimnames(), rownames(), colnames()
```{r}
B <- matrix(sample(0:100, 16), ncol=4)
# rownames, colnames do not assign to the matrix on their own
# also we are using do.NULL=FALSE to enumerate along the size with our prefix
rnames <- rownames(B, do.NULL=FALSE, prefix="eqn")
cnames <- colnames(B, do.NULL=FALSE, prefix="var")
dimnames(B) <- list(rnames, cnames); print(B)
```
## Reading Data in
- **read.table** (inverse of **write.table**) and **read.csv** (identical to read.table, but assumes comma-sep and header=true)
    + takes in tabular data and return a data frame
- **readLines** (inverse of **writeLines**)
    + reads lines of a text file in as a character vector
- **dget** (inverse of **dput**)
    + reads in de-parsed R objects
- **source** (inverse of **dump**)
    + reads in R source code
- **load** (inverse of **save**)
    + for workspaces
- **unserialize** (inverse of **serialize**)
    + for binary data

#### read.table arguments (specify these explicitly for speed):
*file*: name of file, path, connection

*header*: whether or not we have a title row

*sep*: how cols are separated

*colClasses*: character vector indicating class of each col

*nrows*: number rows in dataset

*comment.char*: character string indicating a comment

*skip*: number of lines to skip from beginning

*stringsAsFactors*: should strings be parsed as factors?
-  When it comes across a col that's a character variable it'll assume it to be a factor

## Loading Large Datasets with read.table
Make a rough calculation of memory required to hold dataset. If dataset > RAM, probably stop.
set comment.char = "" if no comment lines
setting colClasses can speed up a LOT

#### Quick and dirty way to assign colClasses
```{r eval=FALSE}
# Just look at the first 100 to set classes
initial <- read.table("dataset.txt", nrows = 100)
# Set class on the initial 100
classes <- sapply(initial, class)
# explicitly set colClasses on entire dataset
tabAll <- read.table("dataset.txt", colClasses = classes)
```

Setting nrows won't speed up R but helps with memory usage. Mild overestimate is okay.
Using 'wc' can tell the # of lines.

Set comment.char = "" if there are no comments in your file.

#### Estimate Memory Needed
1.5 million rows, 120 cols, all numeric. 1.5mil * 120 * 8 (8 bytes per numeric)
~1.34 Gb. Rule of thumb: Need about twice that to load it into R, with overhead, so ~3Gb

## dumping and dputing
- preserve metadata contrasting outputing to table/csv
- edit-able, so in case of corruption, can be opened and examined
- also good for version control
- is a textual format rather than a binary
- not space efficient though

```{r}
y <- data.frame(apple = 0.3, coffee = "almonds"); dput(y)
dput(y, file = "y.R")
y2 <- dget("y.R"); print(y2)
```

dump deals with multiple objects
```{r}
x <- "hello"; y <- 1:4; dump(c("x", "y"), file = "data.R")
rm(x,y)  # gone from workspace
source("data.R")
print(x); print(y)
```

- *file, bzfile, gzfile*: opens connection to a file
- *url*: opens connection to a website
``{r eval=FALSE}
# equivalent to data <- read.csv("data.txt")
con <- file("data.txt", "r")  # opening for reading
data <- read.csv(con)
close(con)

Can use a file connection to read parts of a file
```{r eval=FALSE}
con <- gzfile("test.gz")
x <- readLines(con, 10)
# x[1] is the first line of test.gz, x[10] is the tenth
```

## Subsetting
**[]**: will always return an object of the same class as the original. It can be used to select more than
one element.

**[[]]**: is used to extract elems from a list or df. Can only extract one element and the class
of the returned object may not be the same as the original.

**$**: is used to extract elems from a list or df by name. Similar semantics to [[]].
```{r error=TRUE}
x <- list(5:8, "a", 30)
dim(x[1]) <- c(2,2)   # x[1] is a list
dim(x[[1]]) <- c(2,2); print(x) # x[[1]] is an int vector
```
Subsetting on a range, nested subsetting, logical subsetting
```{r}
x[2:3]   # equivalent here to x[-1], "all but index 1"
x[[1]][2]  # x[[1]] because we don't want a list returned
y <- x[[1]]; y[y >= 7]
```
We can also check ordering on characters by lexicographical order, a>b, etc.

Saving the logical condition
```{r}
x <- sample(c("a", "b", "c"), size = 10, replace = TRUE); print(x)
u <- x > "a"; print(u)
x[u]
```

Subsetting by name
```{r}
x <- list(a = "ok", b = 3.2, c = 11:14)
identical(x[[1]], x$a)
identical(x[[1]], x["a"])  # x["a"] is a list, just like x is
```

We must use single-bracket [] to extract multiple elements of a list.

It makes sense, because we must be assured to get a list back, in case the multiple elements are not
of the same class.
```{r}
x[c(1,3)]    # 1st elem and 3rd elem
```
We can pass [[ ]] a vector but this is for nested extraction.
```{r}
x[[c(3,2)]]  # 2nd elem of the 3rd elem
```

**[[ ]]** can be used with computed indices, $ can only be used with literal names.
```{r error=TRUE}
x <- list(berries = 1:4, pennies = "a")
name <- "berries"
x[[name]]  # computed index for "berries"
x$name     # element 'name' does not exist!
x$berries  # does exist
```

Subsetting matrices, we pass "row, column" and can leave one out.
```{r}
x <- matrix(1:6, 2, 3); print(x)
x[2,1]
x[1, ]  # first row, note: returns vector not matrix
x[, 2]  # second column, note: returns vector not matrix
```

[ ] usually returns an object as the same type, but x[2,1] returned a vector, not a matrix by default.
This can be turned off by setting drop = FALSE.

```{r}
x[2,1, drop = FALSE]
```
Similarly for subsetting out a row or column, which by default returns a vector.
```{r}
x[2, , drop = FALSE]
x[, 2, drop = FALSE]
```
### Partial Matching
```{r}
x <- list(aardvark = 1:6, apple = 12)
x$a
x$ap
x[["ap"]]
x[["ap", exact = FALSE]]
```

### Removing NAs by subsetting by a logical vector
```{r}
x <- c(1,2,NA,4,NA)
bad <- is.na(x)   # logical vector, TRUE if missing, else FALSE
x[!bad]
```
We can use *complete.cases* to return a logical vector that tells us which indices of the objects
all have no missing data
```{r}
y <- c(NA,2,3,4,NA)
good <- complete.cases(x,y); print(good)
x[good]
y[good]
```

### Using complete.cases on a data frame
```{r}
fac <- sample(LETTERS[1:3], 5, replace = TRUE)
(d <- data.frame(x = 1, y = 1:5, fac = fac));
d[1,2] <- NA; d[2,3] <- NA; print(d)
good <- complete.cases(d)
d[good, ]  # good is a logical vector, so we take out the bad rows
```
## Vectorized Operations
```{r}
x <- 0:3; y <- 20:23
print(x+y)
x == 2   # compares each element of x
x+2
```
x has length 4, but 2 is a vector of length 1. Behind the scenes, R is computing x+2 by:
```{r}
x + c(2,2,2,2)
````
If R runs out of elements in a vector operation, it will "recycle" them.
```{r}
c(1,2,3,4) + c(0,10)
c(1,2,3,4) + c(0,1,2)  # R gives warning, but cycles c(0,1,2,0,1,2,...)
```
Vectorized ops on matrices:
```{r}
x <- matrix(1:4, 2,2); y <- matrix(rep(10,4), 2,2)
x / y  # element-wise division
x * y  # element-wise multiplication
x %*% y  # True matrix multiplication
```